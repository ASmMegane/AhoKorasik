Software Protection

Modern UbiComp systems are rarely created from scratch. Components developed by various organizations, with different programming models and tools, as well as various assumptions, are integrated to provide complex capabilities. In this section, we analyze the software ecosystem that emerges from such a world. Figure 2 presents a high-level view of this ecosystem. In the remainder of this section, we will pay particular attention to three aspects of this environment that create security problems for developers: security flaws in C and C ++, the dominant programming languages ??among cyber-physical implementations; interactions between these languages ??and other programming languages, as well as the implications of these interactions for the distributed nature of UbiComp applications. We'll start by diving deeper into the features of C and C ++.

Security type

Most of the software used in UbiComp systems is implemented in C or C ++. This is a fact, given the unprecedented effectiveness of these two programming languages. However, if, on the one hand, C and C ++ produce efficient executable files, on the other hand, their weak type system gives rise to many software vulnerabilities. In the argumentation of a programming language, we say that a type system is weak when it does not support two key properties: progress and conservation [14]. Formal definitions of these properties are not relevant for the subsequent discussion. It is enough to know that due to weak typing, neither C nor C ++ provide, for example, limited access to memory. Therefore, programs written in these languages ??can gain access to invalid memory positions. To illustrate the dangers associated with this possibility, it’s enough to know that access beyond acceptable limits is the principle behind buffer overflow exploits.

The software development community is developing various methods to deal with internal vulnerabilities in C / C ++ / build software. Such methods can be fully static, fully dynamic, or hybrid of both approaches. Static protection mechanisms are implemented at the compiler level; dynamic mechanisms are implemented at runtime level. In the remainder of this section, we list the most famous elements in each category.

Static analysis provides a conservative assessment of program behavior without requiring the execution of such a program. This broad family of methods includes, for example, abstract interpretation [15], model validation [16], and guided evidence [17]. The main advantage of static analysis is the low load on runtime and its reliability: the expected properties will always be preserved. However, static analysis also has disadvantages. In particular, most of the interesting properties of programs lie on unsolvable lands [18]. In addition, verification of many formal properties, although solvable, entails exorbitant computational costs [19].

Dynamic analysis has several varieties: testing (KLEE [20]), profiling (Aprof [21], Gprof [22]), symbolic execution (DART [23]), emulation (Valgrind

[24]) and binary toolkit (Pin [25]). The advantages and limitations of dynamic analysis are exactly the opposite of those found in static methods. Dynamic analysis usually does not cause false alarms: errors are described by examples, which usually lead to sequential playback [26]. However, they are not required to always find vulnerabilities in software. Moreover, the overhead of dynamic analysis still makes it impossible to deploy them in production software [27].

As an intermediate point, several research groups have proposed ways to combine static and dynamic analysis, creating different types of hybrid approaches to protect low-level code. This combination can provide security guarantees that are strictly more powerful than those that can be obtained using static or dynamic approaches when used separately [28]. Nevertheless, negative results still persist: if an attacker can gain control of the program, he or she can usually bypass modern hybrid protection mechanisms, such as the integrity of the
 
control flow [29]. This fact, ultimately, is a consequence of the weak type system adopted in languages, which is usually observed when implementing UbiComp systems. Therefore, the development and implementation of methods that can protect such programming languages ??without jeopardizing their effectiveness to such an extent that they will no longer be adequate to the development of UbiComp remain an open problem.

Despite the difficulties associated with the fact that formal methods play an increasingly important role in the development and implementation of programming languages, much has been done in this area. Certificate e
